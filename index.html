<!DOCTYPE html>
<html>
<head>
	<title>JS13K</title>
</head>
<meta name="viewport" content="user-scalable=0"/>
<body style="background-color: #000">
	<div style="width: 600px; margin: 0 auto; padding-top: 45px;">
		<canvas id="canvas" width="600" height="400"></canvas>
	</div>
	<script>
		// TODO 
		// stop mobile zoom
		// buttons dont work on landscape phone
		// cant restart game on mobile
		// first wave of eneimes is stacked, limit enemies when moving
		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');
		var width = canvas.width;
		var height = canvas.height;
		var enemies = [];
		// Screen Shake
		var shakeTimeInterval = 100;
		var screenShakeDistance = "5px";
		// Spawn enemies and reverse game
		var reverseGame = false;
		var countToReverse = 0;
		var nextWaveReady = true;
		var spawnWaveInterval = 1000;
		var reverseFlipTime = 1000;
		var killsToFlip = 2;

		var ground = {
			width: canvas.width,
			height: 200,
			pos: {
				x: 0, 
				y: 200
			},
			draw: function(){
				ctx.fillStyle = returnFillColor();
				ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
			}
		};

		var player = {
			width: 25,
			height: 25,
			pos: {
				x: 288,
				y: 175
			},
			score: 0,
			draw: function() {
				ctx.font = "48px serif";
				ctx.fillStyle = "#000";
  				ctx.fillText("Score: " + this.score, 220, 50);
				if ( !this.isDead ) {
					ctx.fillStyle = returnFillColor();
					ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
					if ( this.punchLeft && !this.hasPunched ) {
						ctx.fillRect( this.pos.x - 30, this.pos.y + 10, 30, 10);
						setTimeout( function() {
							cancelPunchLeft();
						}, 100);
					}
					else if ( this.punchRight && !this.hasPunched ) {
						ctx.fillRect( this.pos.x + 25, this.pos.y + 8, 30, 10);
						setTimeout( function() {
							cancelPunchRight();
						}, 100);
					}
				} else {
					ctx.font = "48px serif";
					ctx.fillStyle = returnFillColor();
  					ctx.fillText("GAME OVER", 160, 150);
  					ctx.font = "22px serif";
  					ctx.fillText("Press 'space' to play again", 30, 180);
				}
			},
			punchRight: false,
			punchLeft: false,
			hasPunched: false,
			isDead: false
		};

		function createEnemy() {
			var enemy = {
				width: 20,
				height: 40,
				pos: {
					x: 0,
					y: 160
				},
				draw: function(){
					if ( !this.isDead ) {
						ctx.fillStyle = returnFillColor();
						ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
						if ( !player.isDead && !this.headingRight ) {
							this.pos.x += 2;
						} else if ( !player.isDead && this.headingRight ) {
							this.pos.x -= 2;
						}
					} else if ( this.isDead && !this.playedDeathAnim ) {
						var particleCount = 0;
						for ( var i = 0; i < this.deathAnim.length; i++ ) {
							if ( !this.deathAnim[ i ].isDead ) {
								this.deathAnim[ i ].draw();
							} else if ( this.deathAnim[ i ].isDead ) { 
								particleCount++;
							}
						}
						if ( particleCount === this.deathAnim.length ) {
							this.playedDeathAnim = true;
						}
					}
				},
				isDead: false,
				headingRight: false,
				playedDeathAnim: false,
				deathAnim: []
			};
			return enemy;
		}
		
		for ( var i = 0; i < 6; i++ ) {
			var temp = createEnemy();
			if ( i%2 === 0 ) {
				temp.headingRight = true;
				temp.pos.x = 600;
			}
			enemies.push( temp );
		}

		function setupBlocks( coords, isFlipped ) {
			var blocks = [];
			var posX = coords.x + 20; // enemy width
			var posY = coords.y + 50; // enemy height / 2

			for ( var i = 0; i < 4; i++ ) {
				var tempY = posY - ( i * 20 );
				var temp = {
					width: 10,
					height: 10,
					pos: {
						x: posX,
						y: tempY
					},
					draw: function(){
						if ( !this.isDead ) {
							ctx.fillStyle = returnFillColor();
							ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
							if ( !player.isDead ) {
								if ( this.flip ) {
									this.pos.x += 5;
								} else {
									this.pos.x -= 5;	
								}
								if ( this.id < 2 ) {
									this.pos.y += 0.5;
								}else{
									this.pos.y -= 0.5;
								}
								if ( this.TTL < 0 ) {
									this.isDead = true;
								}
								this.width -= 0.25;
								this.height -= 0.25;
								this.TTL--;
							}
						}
					},
					id: i,
					isDead: false,
					TTL: 50,
					flip: isFlipped
				}
				blocks.push(temp);
			}
			return blocks;
		};

		var leftButton = {
			width: 100,
			height: 100,
			pos: {
				x: 50,
				y: 250
			},
			draw: function() {
				if ( this.isPressed ) {
					ctx.fillStyle = returnFillColor();
					ctx.fillRect(this.pos.x + 20, this.pos.y + 20, this.width - 40, this.height - 40);
				}else{
					ctx.fillStyle = '#ccc';
					ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
				}
			},
			isPressed: false
		}

		var rightButton = {
			width: 100,
			height: 100,
			pos: {
				x: 450,
				y: 250
			},
			draw: function() {
				if ( this.isPressed ) {
					ctx.fillStyle = returnFillColor();
					ctx.fillRect(this.pos.x + 20, this.pos.y + 20, this.width - 40, this.height - 40);
				}else{
					ctx.fillStyle = '#ccc';
					ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
				}
			},
			isPressed: false
		}

		function checkAgainstEnemies() {
			for ( var i = 0; i < enemies.length; i++ ) {
				if ( ( enemies[ i ].pos.x + enemies[ i ].width ) > player.pos.x && 
					 !enemies[ i ].headingRight ) {

					player.isDead = true;
				}
				if ( enemies[ i ].pos.x < ( player.pos.x + player.width ) &&
					 enemies[ i ].headingRight ) {

					player.isDead = true;
				}
				if ( player.punchLeft && enemies[ i ].pos.x > (player.pos.x - 60) &&
					 enemies[ i ].pos.x < (player.pos.x + player.width) &&
					 !enemies[ i ].isDead && !player.isDead ) {

					player.score++;	
					screenShake();				
					enemies[ i ].isDead = true;
					countToReverse++;
					enemies[ i ].deathAnim = setupBlocks( enemies[ i ].pos, enemies[ i ].headingRight );
				}
				if ( player.punchRight && enemies[ i ].pos.x < (player.pos.x + 60) &&
					 enemies[ i ].pos.x > (player.pos.x + player.width) &&
					 !enemies[ i ].isDead && !player.isDead ) {

					player.score++;
					screenShake();
					enemies[ i ].isDead = true;
					countToReverse++;
					enemies[ i ].deathAnim = setupBlocks( enemies[ i ].pos, enemies[ i ].headingRight );
				}
			}
		}

		function drawEnemies() {
			for ( var i = 0; i < enemies.length; i++ ) {
				enemies[ i ].draw();
			}
		}

		function spawnEnemies() {
			if ( !nextWaveReady ) return;
			for ( var i = 0; i < enemies.length; i++ ) {
				if ( enemies[ i ].isDead && enemies[ i ].playedDeathAnim ) {
					enemies[ i ].pos.x = 0;
					if ( enemies[ i ].headingRight ) {
						enemies[ i ].pos.x = 600;
					}
					enemies[ i ].isDead = false;
					enemies[ i ].playedDeathAnim = false;
					break;
				}
			}
			nextWaveReady = false;
			setTimeout( function() {
				nextWaveReady = true;
			}, spawnWaveInterval);

			if ( countToReverse > killsToFlip && !reverseGame ) {
				reverseGame = true;
				setTimeout( function() {
					reverseGame = false;
					countToReverse = 0;
				}, reverseFlipTime )
			}
		}

		function update() {
			checkAgainstEnemies();
			spawnEnemies();
		}

		function render() {
			ground.draw();
			player.draw();
			leftButton.draw();
			rightButton.draw();
			drawEnemies();
		}

		function restartGame() {
			player.isDead = false;
			player.score = 0;
			for ( var i = 0; i < enemies.length; i++ ) {
				enemies[ i ].pos.x = 0;
				if ( enemies[ i ].headingRight ) {
					enemies[ i ].pos.x = width;
				}
				enemies[ i ].isDead = false;
			}
		}

		function animate() {
			if ( reverseGame ) {
				ctx.fillStyle = '#000';	
			}else{
				ctx.fillStyle = '#fff';	
			}
			ctx.fillRect(0, 0, width, height);
		  	window.requestAnimationFrame( animate );
		  	update();
		  	render();
		}

		function setPunchLeft() {
			player.punchLeft = true;
			leftButton.isPressed = true;
		}

		function setPunchRight() {
			player.punchRight = true;
			player.hasPunched = false;
			rightButton.isPressed = true;
		}

		function cancelPunchLeft() {
			player.punchLeft = false;
			player.hasPunched = false;
			leftButton.isPressed = false;
		}

		function cancelPunchRight() {
			player.punchRight = false;
			rightButton.isPressed = false;
		}

		window.requestAnimationFrame( animate );
		window.addEventListener('keydown', function(e) {
			if ( e.keyCode === 65 ) { // 65 - Left
				if ( reverseGame ) {
					setPunchRight();
				}else{
					setPunchLeft();	
				}
			}else if ( e.keyCode === 68 ) { // 68 - Right
				if ( reverseGame ) {
					setPunchLeft();
				}else{
					setPunchRight();
				}
			}
		});

		window.addEventListener('keyup', function(e) {
			if ( e.keyCode === 65 ) {
				if ( reverseGame ) {
					cancelPunchRight();
				}else{
					cancelPunchLeft();
				}
			}else if ( e.keyCode === 68 ) {
				if ( reverseGame ) {
					cancelPunchLeft();					
				}else{
					cancelPunchRight();
				}
			}

			if ( e.keyCode === 32 && player.isDead ) {
				restartGame();
			}
		});

		window.addEventListener('mouseup', function(e) {
			cancelPunchLeft();
			cancelPunchRight();
		});

		function insideLeftButton ( mouseCoords ) {
			if ( mouseCoords.x > leftButton.pos.x &&
				 mouseCoords.x < ( leftButton.pos.x + leftButton.width ) &&
				 mouseCoords.y > leftButton.pos.y &&
				 mouseCoords.y < ( leftButton.pos.y + leftButton.height ) ) {

				return true;
			}
			return false;
		}

		function insideRightButton ( mouseCoords ) {
			if ( mouseCoords.x > rightButton.pos.x &&
				 mouseCoords.x < ( rightButton.pos.x + rightButton.width ) &&
				 mouseCoords.y > rightButton.pos.y &&
				 mouseCoords.y < ( rightButton.pos.y + rightButton.height ) ) {

				return true;
			}
			return false;
		}

		window.addEventListener('mousedown', function(e) {
			var X = e.clientX - canvas.offsetLeft;
			var Y = e.clientY - canvas.offsetTop;
			var temp = {
				x: X,
				y: Y
			}
			var clickedLeftBtn = insideLeftButton( temp );
			var clickedRightBtn = insideRightButton( temp );

			if ( clickedLeftBtn ) {
				setPunchLeft();
			}

			if ( clickedRightBtn ) {
				setPunchRight();
			}
		});

		window.addEventListener('touchstart', function(e) {
			for ( var i = 0; i < e.touches.length; i++ ) {

				checkUITouch( e.touches[ i ] );
			}
		});

		screen.addEventListener("orientationchange", function() {
    		console.log("the orientation of the device is now " + screen.orientation);
		});

		function checkUITouch( e ) {
			var X = e.clientX - canvas.offsetLeft;
			var Y = e.clientY - canvas.offsetTop;
			var temp = {
				x: X,
				y: Y
			}
			var clickedLeftBtn = insideLeftButton( temp );
			var clickedRightBtn = insideRightButton( temp );

			if ( clickedLeftBtn ) {
				setPunchLeft();
			}

			if ( clickedRightBtn ) {
				setPunchRight();
			}
		}

		window.addEventListener('touchend', function(e) {
			cancelPunchLeft();
			cancelPunchRight();
		});

		function screenShake() {
			canvas.style.marginLeft = screenShakeDistance;
			setTimeout( function() {
				canvas.style.marginLeft = "0";
				setTimeout( function() {
					canvas.style.marginRight = screenShakeDistance;
					setTimeout( function() {
						canvas.style.marginRight = "0";
					}, shakeTimeInterval);
				}, shakeTimeInterval);
			}, shakeTimeInterval);
		}

		function returnFillColor () {
			if ( reverseGame ) {
				return '#fff';
			}
			return '#000';	
		}
	</script>

</body>
</html>